#!/usr/bin/env python
import sys, re, errno
import hashsplit, git, options
from helpers import *

saved_errors = []

def add_error(e):
    saved_errors.append(e)
    log('\n%s\n' % e)


def direxpand(names):
    for n in names:
        try:
            for sub in os.listdir(n):
                subfull = os.path.join(n, sub)
                for sub2 in direxpand([subfull]):
                    yield sub2
        except OSError, e:
            if e.errno == errno.ENOTDIR:
                yield n
            elif e.errno in [errno.ENOENT, errno.EPERM, errno.EACCES]:
                add_error(e)
            else:
                raise
            

def _normpath(dir):
    p = os.path.normpath(dir)
    return (p != '.') and p or ''


class Tree:
    def __init__(self, parent, name):
        assert(name != '.')
        assert(not (parent and not name))
        self.parent = parent
        self.name = name
        self.sha = None
        self.children = {}
        if self.parent:
            self.parent.children[self.name] = self
    
    def fullpath(self):
        if self.parent:
            return os.path.join(self.parent.fullpath(), self.name)
        else:
            return self.name
        
    def gettop(self):
        p = self
        while p.parent:
            p = p.parent
        return p
        
    def getdir(self, dir):
        # FIXME: deal with '..' somehow
        if dir.startswith('/'):
            dir = dir[1:]
        top = self.gettop()
        if not dir:
            return top
        for part in _normpath(dir).split('/'):
            sub = top.children.get(part)
            if not sub:
                sub = top.children[part] = Tree(top, part)
            top = sub
        return top
    
    def addfile(self, mode, fullname, id):
        (dir, name) = os.path.split(fullname)
        self.getdir(dir).children[name] = (mode, name, id)
        
    def shalist(self):
        for c in self.children.values():
            if isinstance(c, tuple):  # sha1 entry for a file
                yield c
            else:  # tree
                t = ('40000', c.name, c.gen_tree())
                yield t
        
    def gen_tree(self):
        if not self.sha:
            self.sha = git.gen_tree(self.shalist())
        return self.sha


optspec = """
bup save [-tc] [-n name] <filenames...>
--
t,tree     output a tree id
c,commit   output a commit id
n,name=    name of backup set to update (if any)
v,verbose  increase log output (can be used more than once)
"""
o = options.Options('bup save', optspec)
(opt, flags, extra) = o.parse(sys.argv[1:])

if not (opt.tree or opt.commit or opt.name):
    log("bup save: use one or more of -t, -c, -n\n")
    o.usage()

if opt.verbose >= 2:
    git.verbose = opt.verbose - 1
    hashsplit.split_verbosely = opt.verbose - 1

root = Tree(None, '')
for fn in direxpand(extra):
    if opt.verbose:
        log('\n%s ' % fn)
    try:
        # FIXME: symlinks etc.
        f = open(fn)
    except IOError, e:
        add_error(e)
        continue
    except OSError, e:
        add_error(e)
        continue
    (mode, id) = hashsplit.split_to_blob_or_tree([f])
    root.addfile(mode, fn, id)
tree = root.gen_tree()
if opt.verbose:
    log('\n')
if opt.tree:
    print tree.encode('hex')
if opt.commit or opt.name:
    msg = 'bup save\n\nGenerated by command:\n%r' % sys.argv
    ref = opt.name and ('refs/heads/%s' % opt.name) or None
    commit = git.gen_commit_easy(ref, tree, msg)
    if opt.commit:
        print commit.encode('hex')

git.flush_pack()

if saved_errors:
    log('WARNING: %d errors encountered while saving.\n' % len(saved_errors))
